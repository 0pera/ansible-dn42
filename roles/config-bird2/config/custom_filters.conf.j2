# Custom filters for AS4242421080
{#
__        ___    ____  _   _ ___ _   _  ____ _
\ \      / / \  |  _ \| \ | |_ _| \ | |/ ___| |
 \ \ /\ / / _ \ | |_) |  \| || ||  \| | |  _| |
  \ V  V / ___ \|  _ <| |\  || || |\  | |_| |_|
   \_/\_/_/   \_\_| \_\_| \_|___|_| \_|\____(_)

__        ___    ____  _   _ ___ _   _  ____ _ _ _
\ \      / / \  |  _ \| \ | |_ _| \ | |/ ___| | | |
 \ \ /\ / / _ \ | |_) |  \| || ||  \| | |  _| | | |
  \ V  V / ___ \|  _ <| |\  || || |\  | |_| |_|_|_|
   \_/\_/_/   \_\_| \_\_| \_|___|_| \_|\____(_|_|_)

This file contains examples of custom route tweaks that I *happen to be using* on my network.
Many of these filters are designed specifically for my AS, and altogether they drastically alter the way that my network
processes dn42 routes.

In short, you are NOT meant to copy what's here. ESPECIALLY DON'T COPY PIECES YOU HAVEN'T TAKEN THE TIME TO UNDERSTAND YOURSELF!
If you just want BGP community support, look at community_filters.conf (it's based off the dn42 Wiki anyways)

#}

# Node ID is AS4242421080-specific and used for informational communities and route pinning. You probably don't need it
define NODEID = {{ ownip.rsplit('.', 1)[1] }};

define LC_ORIGIN_REGION = 101;
define LC_ORIGIN_NODEID = 103;

# Subtract x from bgp_local_pref, while checking for underflow
function safe_lower_pref(int x) {
    if (bgp_local_pref > x) then {
        bgp_local_pref = bgp_local_pref - x;
    } else {
        bgp_local_pref = 0;
    }
}

function read_bgp_blackhole() {
    # Implement BLACKHOLE community as defined by RFC 7999
    # Based off https://bird.network.cz/pipermail/bird-users/2016-October/010705.html
    if (source = RTS_BGP && (65535, 666) ~ bgp_community) then {
        dest = RTD_BLACKHOLE;
    }
}

function prefer_same_region_origin(int base_weight) {
    # Prefer routes originating from the same region
    # This is basically cold-potato routing, where we prefer routing traffic through
    # our network and only exiting at the border router closest to the destination network.
    if ((64511, DN42_REGION) ~ bgp_community) then {
        bgp_local_pref = bgp_local_pref + base_weight/bgp_path.len;
    } else {
        # Treat North America - Central and East as the same region. These regions are only ~20 ms apart
        # so forcing traffic to either single one is often counterproductive.
        if (DN42_REGION ~ [42..43] && bgp_community ~ [(64511, 42..43)]) then {
            bgp_local_pref = bgp_local_pref + base_weight/bgp_path.len;
        }

    }
}

# Special cases I've added for route optimization, your mileage may vary
function handle_special_cases() {
    # Pin the following to EU:
    # - AS4242420101 / CCCDA
    # - AS65043 / ICVPN-DREILAENDERECK
    if (DN42_REGION != 41 && bgp_path ~ [= * [4242420101, 65043] * =]) then {
        safe_lower_pref(20);
    }
}

function ebgp_import_filter() {
    handle_special_cases();

    # Reject routes with unreasonable path lengths
    if (bgp_path.len > 12) then {
        reject;
    }

    # Apply same region filtering on routes which specify the dn42 community tags
    if (bgp_community ~ [(64511, 41..44), (64511, 52)]) then {
        prefer_same_region_origin(200);
    } else {
        # Some peers attach region communities to routes in transit, which screws up calculations
        # for prefixes where some paths have a region and others don't.
        # In these cases just weigh local_pref based on AS path length.
        bgp_local_pref = bgp_local_pref + 200/bgp_path.len;
    }
    read_bgp_blackhole();

    # Informational communities: region of import & node ID of import
    bgp_large_community.delete([(OWNAS, LC_ORIGIN_REGION, 41..53)]);
    bgp_large_community.delete([(OWNAS, LC_ORIGIN_NODEID, 112..127)]);
    bgp_large_community.add((OWNAS, LC_ORIGIN_REGION, DN42_REGION));
    bgp_large_community.add((OWNAS, LC_ORIGIN_NODEID, NODEID));
};

function ebgp_export_filter() {
    # 2021-03-13: don't export paths from long flapping ASes
    if (bgp_path.last ~ [64875]) then {
        reject;
    }
};

function ibgp_import_filter() {
    # Only pass routes that are learned from BGP and don't match our networks
    if (source != RTS_BGP || is_self_net() || is_self_net_v6()) then {
        reject;
    }
    if (!is_valid_network() && !is_valid_network_v6()) then {
        # Not routable for dn42
        reject;
    }

    # Penalize routes learned from another region that have high (>50ms) latency
    if ((OWNAS, LC_ORIGIN_REGION, DN42_REGION) !~ bgp_large_community && bgp_community ~ [(64511, 5..9)]) then {
        safe_lower_pref(100 / bgp_path.len);
        safe_lower_pref(1);
    }

    accept;
}

function ibgp_export_filter() {
    if (source != RTS_BGP || is_self_net() || is_self_net_v6()) then {
        reject;
    }
    accept;
}
